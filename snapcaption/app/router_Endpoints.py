from fastapi import APIRouter, HTTPException, UploadFile, File, Body
from fastapi.responses import JSONResponse
from azure.storage.blob import BlobServiceClient, ContentSettings
import uuid
from dotenv import load_dotenv
import os, requests, logging
from azure.cosmos import CosmosClient

load_dotenv()

router = APIRouter()

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize the BlobServiceClient with connection string
connection_string = os.getenv("BLOB_STORAGE_CONNECTION_STRING")
blob_service_client = BlobServiceClient.from_connection_string(connection_string)
container_name = os.getenv("BLOB_CONTAINER")

# Initialize the Computer Vision API client
cv_key = os.getenv("COMPUTER_VISION_KEY")
cv_endpoint = (
    os.getenv("COMPUTER_VISION_CONNECTION_STRING")
    + "computervision/imageanalysis:analyze?api-version=2023-04-01-preview"
)

# Initialize Azure OpenAI client
openai_key = os.getenv("OPENAI_KEY")
openai_endpoint = os.getenv("OPENAI_CONNECTION_STRING")

#initialize Cosmos CB CLient
cosmos_db_connection_string = os.getenv("COSMOS_CONNECTION_STRING")
cosmos_db_database = os.getenv("COSMOS_DATABASE")
cosmos_db_container = os.getenv("COSMOS_COLLECTION")

#debugging purposes
if not cosmos_db_connection_string:
    raise ValueError("COSMOS_DB_CONNECTION_STRING is not set. Check your .env file.")

logging.info(f"Using database: {cosmos_db_database}, container: {cosmos_db_container}")

try:
    cosmos_client = CosmosClient.from_connection_string(cosmos_db_connection_string)
    database = cosmos_client.get_database_client(cosmos_db_database)
    container = database.get_container_client(cosmos_db_container)
except Exception as e:
    logger.error(f"Error connecting to Cosmos DB: {e}")
    raise HTTPException(
        status_code=500, detail=f"Failed to connect to Cosmos DB: {str(e)}"
    )

@router.get("/")
async def read_root():
    return {"message": "Welcome to SnapCaption!"}


@router.post("/upload_image")
async def upload_image(image: UploadFile = File(...)):
    # Generate a unique ID for the image
    image_id = str(uuid.uuid4())

    try:
        # Create a blob client using the unique ID as the name for the blob
        blob_client = blob_service_client.get_blob_client(
            container=container_name, blob=image_id
        )

        # Upload the image to blob storage
        image_data = await image.read()

        blob_client.upload_blob(
            image_data,
            overwrite=True,
            content_settings=ContentSettings(image.content_type),
        )

        # Generate a URL for the uploaded image
        image_url = blob_client.url
        print(f"Image uploaded. URL: {image_url}")

        return {
            "image_id": image_id,
            "image_url": image_url,
            "filename": image.filename,
            "message": "Image uploaded successfully",
        }
    except Exception as e:
        print(f"Error during image upload: {e}")  # Log the exact error
        raise HTTPException(status_code=500, detail=f"Failed to upload image: {str(e)}")


@router.get("/get_caption")
async def get_caption(image_url: str):
    """
    Generate a caption for the image using Azure Computer Vision.
    """
    # Define the request headers with the subscription key
    headers = {"Ocp-Apim-Subscription-Key": cv_key, "Content-Type": "application/json"}

    params = {"features": "denseCaptions", "language": "en"}

    # Define the data payload with the image URL
    data = {"url": image_url}

    try:
        # Make a request to the Computer Vision API
        response = requests.post(cv_endpoint, headers=headers, params=params, json=data)
        response.raise_for_status()  # Raise an error for non-200 responses
        result = response.json()

        # Extract the caption from the response
        if "denseCaptionsResult" in result:
            return result
        else:
            return JSONResponse(
                content={"caption": "No description available for the image."},
                status_code=404,
            )

    except requests.exceptions.RequestException as e:
        # Handle any request errors
        raise HTTPException(status_code=500, detail=f"Error generating caption: {e}")


@router.post("/generate_caption")
async def generate_caption(captions: list[str]):
    """
    Endpoint to process captions from Azure Computer Vision
    and refine them using Azure OpenAI.
    """
    # Validate the input
    if (
        not captions
        or not isinstance(captions, list)
        or not all(isinstance(c, str) for c in captions)
    ):
        raise HTTPException(
            status_code=400, detail="Invalid input: must provide a list of strings."
        )

    bullet_points = "\n".join(f"{caption}" for caption in captions)

    # Combine all captions into a single prompt for refinement
    prompt = f"The following captions were generated by a vision model:\n{bullet_points}\n\nProvide a more detailed and descriptive caption for the image overall:"

    print("Prompt: ", prompt)
    # Call Azure OpenAI API
    url = f"{openai_endpoint}"
    headers = {
        "Content-Type": "application/json",
        "api-key": openai_key,
    }
    payload = {
        "messages": [
            {
                "role": "system",
                "content": "You are an assistant that refines image captions.",
            },
            {"role": "user", "content": prompt},
        ],
        "temperature": 0.2,
        "top_p": 0.5,
        "max_tokens": 200,  # Adjust based on your needs
    }

    logger.info(f"Payload: {payload}")

    try:
        response = requests.post(url, headers=headers, json=payload)
        response.raise_for_status()

        # Parse the refined caption
        result = response.json()

        # Access the refined caption correctly
        if "choices" in result and len(result["choices"]) > 0:
            choice = result["choices"][0]
            if "message" in choice and "content" in choice["message"]:
                refined_caption = choice["message"]["content"].strip()
                logger.info(f"Refined Caption: {refined_caption}")
                return {"refined_caption": refined_caption}
            else:
                logger.error("Missing 'message' or 'content' in choice.")
                raise HTTPException(
                    status_code=500,
                    detail="Azure OpenAI API error: Missing 'message' or 'content' in response.",
                )
        else:
            logger.error("Missing 'choices' or 'choices' is empty in response.")
            raise HTTPException(
                status_code=500,
                detail="Azure OpenAI API error: Missing 'choices' in response.",
            )

    except requests.exceptions.HTTPError as http_err:
        # Extract error message from the response if available
        try:
            error_detail = (
                response.json().get("error", {}).get("message", str(http_err))
            )
        except Exception:
            error_detail = str(http_err)
        logger.error(f"Azure OpenAI API HTTP Error: {error_detail}")
        raise HTTPException(
            status_code=500, detail=f"Azure OpenAI API error: {error_detail}"
        )
    except KeyError as e:
        # Handle cases where the expected keys are not present in the response
        logger.error(f"KeyError: Missing key {str(e)} in the response.")
        raise HTTPException(
            status_code=500, detail=f"Error: Missing key {str(e)} in the response."
        )
    except Exception as e:
        logger.error(f"Unexpected Error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error: {str(e)}")






@router.post("/store_caption")
async def store_caption(caption: str = Body(..., embed=True)):
    """
    Store a caption in CosmosDB as an array of strings.
    - **caption**: The caption as a string. It will be split into multiple strings (sentences).
    """
    logging.info(f"Incoming caption: {caption}")

    if not caption or not isinstance(caption, str):
        raise HTTPException(status_code=400, detail="Invalid input: Caption must be a string.")

    caption = caption.strip()
    if len(caption) < 5:  # Minimum meaningful length for a paragraph
        raise HTTPException(status_code=400, detail="Caption is too short to be meaningful.")

    # Split paragraph into sentences and trim each sentence
    sentences = [sentence.strip() for sentence in caption.split('.') if sentence.strip()]

    try:
        # Create a document for CosmosDB
        document = {
            "id": str(uuid.uuid4()),  # Generate unique ID
            "sentences": sentences  # Store sentences as an array
        }

        # Save the document in CosmosDB
        container.create_item(body=document)

        logging.info(f"Stored document: {document}")
        return {"message": "Caption stored successfully.", "id": document["id"]}
    except Exception as e:
        logging.error(f"Error storing caption: {e}")
        raise HTTPException(status_code=500, detail="Failed to store caption.")





@router.get("/get_caption")
async def get_captions():
    """
    Retrieve all captions from CosmosDB as plain strings.
    """
    try:
        logging.info("Fetching all captions from CosmosDB.")

        # Query to fetch all items
        query = "SELECT c.id, c.caption FROM c"
        items = list(container.query_items(query=query, enable_cross_partition_query=True))

        if not items:
            logging.warning("No captions found in the database.")
            return {"message": "No captions found.", "captions": []}

        # Clean and format results
        cleaned_items = []
        for item in items:
            caption = item.get("caption", None)
            if isinstance(caption, str):  # Ensure it's a valid string
                cleaned_items.append({"id": item["id"], "caption": caption})
            else:
                logging.warning(f"Skipping item with ID {item['id']} due to invalid 'caption'.")

        logging.info(f"Retrieved captions: {cleaned_items}")
        return {"captions": cleaned_items}
    except Exception as e:
        logging.error(f"Error retrieving captions: {e}")
        raise HTTPException(status_code=500, detail="Failed to retrieve captions.")@router.get("/get_captions")


# @router.post("/cleanup_captions")
# async def cleanup_captions():
#     """
#     Cleanup existing data in CosmosDB to ensure all captions are plain strings.
#     """
#     try:
#         logging.info("Starting cleanup of captions in CosmosDB.")

#         # Partition key field (replace with your actual partition key field)
#         partition_key_field = "metadata"  # Replace 'id' with the actual partition key field name

#         # Iterate over all items in the container
#         for item in container.read_all_items():
#             if "paragraph" in item:
#                 # Ensure the caption is a valid plain string
#                 if not isinstance(item["paragraph"], str):
#                     logging.warning(f"Fixing invalid paragraph for item ID {item['id']}")
#                     item["caption"] = "Invalid paragraph cleaned"
#                     container.replace_item(item=item["id"], body=item)
#             else:
#                 # Delete documents without a 'caption' field
#                 partition_key = item.get(partition_key_field, None)
#                 if partition_key is None:
#                     logging.warning(f"Skipping deletion for item ID {item['id']} due to missing partition key.")
#                     continue

#                 logging.warning(f"Deleting item with ID {item['id']} due to missing 'caption' field.")
#                 container.delete_item(item=item["id"], partition_key=partition_key)

#         logging.info("Cleanup completed successfully.")
#         return {"message": "Cleanup completed successfully."}
#     except Exception as e:
#         logging.error(f"Error during cleanup: {e}")
#         raise HTTPException(status_code=500, detail="Failed to cleanup captions.")
